# Copy to .env and fill. Do not commit .env (secrets).
# Chat: set at least one platform. Multiple can be enabled.
# Telegram: get token from @BotFather. If the bot had a webhook before, the app will clear it on start so polling works.
TELEGRAM_BOT_TOKEN=your-telegram-bot-token
# Unified chat (dashboard + Telegram same thread): set your Telegram user id (e.g. from @userinfobot). Vision pushes replies to this user; Chat routes this user's messages to the same conversation as the dashboard.
TELEGRAM_MAIN_USER_ID=
# When 1, Telegram users (except main) must be approved in Settings → Pairing before the bot replies. They get a code to enter in the dashboard.
TELEGRAM_PAIRING_ENABLED=
# Chat calls this URL for unified Telegram flow (main user). Default http://localhost:3000
VISION_CHAT_URL=http://localhost:3000
# Webhook base URL for signature validation (Twilio/Line). e.g. https://your-domain.com
CHAT_WEBHOOK_BASE_URL=
# WhatsApp (Twilio): set all three, then set Twilio WhatsApp webhook to http(s)://your-host:3010/webhook/whatsapp
TWILIO_ACCOUNT_SID=
TWILIO_AUTH_TOKEN=
TWILIO_WHATSAPP_FROM=whatsapp:+14155238886
# Slack (Socket Mode): no webhook needed
SLACK_BOT_TOKEN=
SLACK_APP_TOKEN=
# Line: set token and secret (secret required for webhook signature validation), then set webhook to http(s)://your-host:3010/webhook/line
LINE_CHANNEL_ACCESS_TOKEN=
LINE_CHANNEL_SECRET=
# Google Chat: set one of these, then set app webhook to http(s)://your-host:3010/webhook/google-chat
GOOGLE_CHAT_PROJECT_ID=
GOOGLE_CHAT_WEBHOOK_URL=
CHAT_WEBHOOK_PORT=3010

# LLM: use OpenRouter (default) or OpenAI. Set LLM_PROVIDER=openrouter|openai and the matching key.
LLM_PROVIDER=openrouter
OPENROUTER_API_KEY=your-openrouter-api-key
OPENAI_API_KEY=your-openai-api-key
AI_MODEL=anthropic/claude-3.5-sonnet

# Draft LLM (optional): use a cheaper model for copies, captions, long-form writing. Saves tokens on the main model.
# e.g. your ChatGPT/OpenAI key; only this model is used for "draft" tasks (Instagram copies, emails, etc.).
DRAFT_OPENAI_API_KEY=
DRAFT_AI_MODEL=gpt-4o-mini

# Image generation (Nano Banana Pro): set NANO_BANANA_PRO_API_KEY. Used for generate_image intent. Get key at https://nanobnana.com/dashboard/api-keys
NANO_BANANA_PRO_API_KEY=

# Instagram (browser flow): post from agent. Set both to enable instagram_post intent.
INSTAGRAM_USER=
INSTAGRAM_PASSWORD=

# Metricool (browser flow): schedule posts. Set both to enable metricool_schedule intent.
METRICOOL_EMAIL=
METRICOOL_PASSWORD=

# Browser visit (browser_visit intent): open URL in real browser. If the site requires login, set all three so the agent logs in first, then visits the requested URL.
BROWSER_VISIT_LOGIN_URL=
BROWSER_VISIT_USER=
BROWSER_VISIT_PASSWORD=
# Optional: use a visible Chrome so you see the agent navigate (Metricool, browser_visit).
# With terminal (start.sh): set BROWSER_VISIBLE=1 and restart; start.sh will launch Chrome. Without: run Chrome yourself with --remote-debugging-port=9222.
# With app (DMG/EXE): set BROWSER_VISIBLE=1 in Settings or .env; the app will launch Chrome when you open it (no terminal needed).
BROWSER_VISIBLE=
BROWSER_DEBUGGING_PORT=9222

# Autonomous agents: they wake when the world changes (new trends) or when you call POST /api/trigger.
# Signal watcher (recommended): when SIGNAL_WATCHER_ENABLED=true, Jellyfish checks trends every N min; if they changed, wakes all agents (e.g. Social Media Manager creates posts). No cron — reacts to "something new".
SIGNAL_WATCHER_ENABLED=true
SIGNAL_WATCHER_INTERVAL_MS=1800000
# Optional: fixed timer (cron-style). Only if you also want "every N hours" on top of the watcher.
SCHEDULER_ENABLED=
SCHEDULER_INTERVAL_MS=86400000
SCHEDULER_REPORT_CONVERSATION_ID=
SCHEDULER_INITIAL_DELAY_MS=60000

# Redis: use REDIS_URL (e.g. redis://:password@host:port) or REDIS_HOST + REDIS_PORT + REDIS_PASSWORD
REDIS_URL=
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
DATABASE_URL=./sqlite.db
